package ExerciseClass;

import java.util.Objects;

// 算式抽象类
public abstract class AbstractEquation implements IEquation {
    private short operand1;  // 操作数1
    private short operand2;  // 操作数2
    private char operator;   // 操作符

    /**
     * 构造函数，用于初始化算式的操作数和操作符。
     *
     * @param operand1 第一个操作数
     * @param operand2 第二个操作数
     * @param operator 操作符
     */
    public AbstractEquation(short operand1, short operand2, char operator) {
        this.operand1 = operand1;
        this.operand2 = operand2;
        this.operator = operator;
    }

    /**
     * 无参构造函数，用于创建未初始化的算式对象。
     */
    public AbstractEquation() {
    }

    /**
     * 获取操作数1。
     *
     * @return 操作数1
     */
    @Override
    public short getOperand1() {
        return operand1;
    }

    /**
     * 获取操作数2。
     *
     * @return 操作数2
     */
    @Override
    public short getOperand2() {
        return operand2;
    }

    /**
     * 获取操作符。
     *
     * @return 操作符
     */
    @Override
    public char getOperator() {
        return operator;
    }

    /**
     * 判断两个算式对象是否相等。
     *
     * @param obj 要比较的对象
     * @return 如果对象相等，返回true；否则返回false
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        AbstractEquation equation = (AbstractEquation) obj;
        return operand1 == equation.operand1 && operand2 == equation.operand2 && operator == equation.operator;
    }

    /**
     * 计算并返回算式对象的哈希码。
     *
     * @return 哈希码值
     */
    @Override
    public int hashCode() {
        return Objects.hash(operand1, operand2, operator);
    }

    /**
     * 返回算式对象的字符串表示形式，格式为 "operand1 operator operand2"。
     *
     * @return 字符串表示形式
     */
    @Override
    public String toString() {
        return operand1 + " " + operator + " " + operand2;
    }
}
package ExerciseClass;

/**
 * 加法算式类，继承自抽象算式类 AbstractEquation。
 */
public class AddEquation extends AbstractEquation {

    /**
     * 构造函数，用于初始化加法算式的操作数和操作符。
     *
     * @param operand1 第一个操作数
     * @param operand2 第二个操作数
     */
    public AddEquation(short operand1, short operand2) {
        // 调用父类构造函数，设置操作数和操作符
        super(operand1, operand2, '+');
    }

    /**
     * 计算并返回加法算式的结果。
     *
     * @return 加法算式的计算结果
     */
    @Override
    public int calculate() {
        // 返回操作数1和操作数2的和
        return getOperand1() + getOperand2();
    }
}
package ExerciseClass;

/**
 * 算式约束接口。
 * 定义了检查算式是否满足特定条件的方法。
 */
public interface EquationChecker {

    /**
     * 检查给定算式是否满足约束条件。
     *
     * @param equation 要检查的算式对象，实现了 IEquation 接口
     * @return 如果算式满足约束条件，返回 true；否则返回 false
     */
    boolean check(IEquation equation);
}
package ExerciseClass;

/**
 * 范围约束算式检查器类。
 * 实现了 EquationChecker 接口，用于检查算式的操作数和结果是否在指定范围内。
 */
public class EquationCheckerOfRange implements EquationChecker {
    private int min;  // 允许的最小值
    private int max;  // 允许的最大值

    /**
     * 构造函数，用于初始化范围约束算式检查器的最小值和最大值。
     *
     * @param min 允许的最小值
     * @param max 允许的最大值
     */
    public EquationCheckerOfRange(int min, int max) {
        this.min = min;
        this.max = max;
    }

    /**
     * 检查给定算式是否满足范围约束条件。
     *
     * @param equation 要检查的算式对象，实现了 IEquation 接口
     * @return 如果算式的操作数和结果都在指定范围内，返回 true；否则返回 false
     */
    @Override
    public boolean check(IEquation equation) {
        // 计算算式的结果
        int result = equation.calculate();

        // 检查操作数1、操作数2和结果是否都在指定范围内
        return equation.getOperand1() >= min && equation.getOperand1() <= max &&
                equation.getOperand2() >= min && equation.getOperand2() <= max &&
                result >= min && result <= max;
    }
}
package ExerciseClass;
import java.util.*;

/**
 * 方程集合类，实现了 Iterable 接口，用于存储和操作 IEquation 接口的方程对象。
 */
public class EquationCollection implements Iterable<IEquation> {
    private final Set<IEquation> equationSet = new HashSet<>();

    /**
     * 生成指定数量的方程，并使用提供的 EquationChecker 进行约束检查。
     *
     * @param n       要生成的方程数量
     * @param checker 约束检查器，用于检查生成的方程是否符合特定条件
     */
    public void generate(int n, EquationChecker checker) {
        EquationFactory factory = new EquationFactory();
        Random random = new Random();

        // 循环生成方程，直到达到指定数量 n
        for (int i = 0; i < n; i++) {
            // 从工厂获取随机方程
            IEquation equation = factory.getEquationRandom();

            // 检查方程是否满足约束条件且未重复
            while (!checker.check(equation) || equationSet.contains(equation)) {
                // 如果不满足条件，重新获取随机方程
                equation = factory.getEquationRandom();
            }

            // 将满足条件的方程添加到集合中
            equationSet.add(equation);
        }
    }

    /**
     * 清空方程集合。
     */
    public void clear() {
        equationSet.clear();
    }

    /**
     * 将给定的方程集合添加到当前集合中。
     *
     * @param equations 要添加的方程集合
     */
    public void addAll(Collection<IEquation> equations) {
        equationSet.addAll(equations);
    }

    /**
     * 处理数据库异常，打印异常信息并在实际应用中可能需要显示错误消息给用户。
     *
     * @param e 异常对象
     */
    private void 处理数据库异常(Exception e) {
        e.printStackTrace();
        // 在实际应用中，可能需要处理异常，例如显示错误消息给用户
    }

    /**
     * 获取方程集合的列表形式。
     *
     * @return 包含方程集合所有元素的列表
     */
    public List<IEquation> getEquationsList() {
        return new ArrayList<>(equationSet);
    }

    /**
     * 检查方程集合是否为空。
     *
     * @return 如果方程集合为空，返回 true；否则返回 false
     */
    public boolean isEmpty() {
        return equationSet.isEmpty();
    }

    /**
     * 实现 Iterable 接口，以便使用 foreach 循环遍历方程集合。
     *
     * @return 方程集合的迭代器
     */
    @Override
    public Iterator<IEquation> iterator() {
        return equationSet.iterator();
    }
}
package ExerciseClass;

import java.util.Random;

/**
 * EquationFactory 工厂类，用于创建随机算式对象。
 * 该类包含方法，能够随机生成加法或减法算式。
 */
public class EquationFactory {

    /**
     * 随机返回算数式，可以是加法或减法。
     *
     * @return 随机生成的算数式对象，实现了 IEquation 接口
     */
    public IEquation getEquationRandom() {
        Random random = new Random();

        // 生成随机的操作数1和操作数2（范围在0到100之间）
        short operand1 = (short) random.nextInt(101);
        short operand2 = (short) random.nextInt(101);

        // 随机选择是加法还是减法
        if (random.nextBoolean()) {
            // 返回加法算式对象
            return new AddEquation(operand1, operand2);
        } else {
            // 返回减法算式对象
            return new SubEquation(operand1, operand2);
        }
    }
}
package ExerciseClass;

/**
 * 算式接口，定义了表示数学算式的方法。
 */
public interface IEquation {

    /**
     * 获取算式的第一个操作数。
     *
     * @return 第一个操作数
     */
    short getOperand1();

    /**
     * 获取算式的第二个操作数。
     *
     * @return 第二个操作数
     */
    short getOperand2();

    /**
     * 获取算式的操作符。
     *
     * @return 操作符
     */
    char getOperator();

    /**
     * 计算并返回算式的结果。
     *
     * @return 算式的计算结果
     */
    int calculate();

    /**
     * 返回算式的字符串表示形式。
     *
     * @return 字符串表示形式
     */
    String toString();
}
package ExerciseClass;

/**
 * 减法算式类，继承自抽象算式类 AbstractEquation。
 */
public class SubEquation extends AbstractEquation {

    /**
     * 构造函数，用于初始化减法算式的操作数和操作符。
     *
     * @param operand1 第一个操作数
     * @param operand2 第二个操作数
     */
    public SubEquation(short operand1, short operand2) {
        // 调用父类构造函数，设置操作数和操作符
        super(operand1, operand2, '-');
    }

    /**
     * 计算并返回减法算式的结果。
     *
     * @return 减法算式的计算结果
     */
    @Override
    public int calculate() {
        // 返回操作数1减去操作数2的结果
        return getOperand1() - getOperand2();
    }
}
package javafx;

import ExerciseClass.EquationCheckerOfRange;
import ExerciseClass.EquationCollection;
import ExerciseClass.IEquation;
import Mysql.MySQLUtil;
import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.chart.PieChart;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.stage.Stage;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

/**
 * JavaFX 应用程序类，用于生成口算习题并进行用户交互。
 */
public class EquationApplication extends Application {
    private static final int NUM_QUESTIONS = 5;
    private EquationCollection equationCollection;
    private VBox questionVBox;
    private TextField[] answerFields;
    private PieChart accuracyChart;

    @Override
    public void start(Stage stage) {
        // 初始化算式集合
        equationCollection = new EquationCollection();

        // 菜单
        MenuItem generateMenuItem = new MenuItem("生成习题");
        MenuItem saveMenuItem = new MenuItem("保存习题");
        MenuItem loadMenuItem = new MenuItem("读取习题");
        MenuItem checkMenuItem = new MenuItem("检查习题");

        // 菜单项事件处理
        generateMenuItem.setOnAction(event -> {
            // 生成并展示新的习题
            initializeUI();
        });

        loadMenuItem.setOnAction(event -> {
            // 从数据库加载并展示最新的五道题目
            loadAndDisplayDatabaseQuestions();
        });

        // 保存习题菜单项事件处理
        saveMenuItem.setOnAction(event -> saveEquationsToDatabase());

        // 检查习题菜单项事件处理
        checkMenuItem.setOnAction(event -> {
            // 检查答案并显示准确度对话框
            int correctCount = checkAnswers(answerFields);
            showAccuracyDialog(correctCount);
        });

        Menu fileMenu = new Menu("文件");
        fileMenu.getItems().addAll(generateMenuItem, saveMenuItem, loadMenuItem, checkMenuItem);
        MenuBar menuBar = new MenuBar();
        menuBar.getMenus().addAll(fileMenu);

        // 控件
        questionVBox = new VBox();
        questionVBox.setSpacing(10);
        questionVBox.setPadding(new Insets(20));

        answerFields = new TextField[NUM_QUESTIONS];
        accuracyChart = new PieChart(); // 创建新的 PieChart 实例

        // 初始化 UI
        initializeUI();

        // 布局
        BorderPane borderPane = new BorderPane();
        borderPane.setTop(menuBar);
        borderPane.setCenter(questionVBox);

        // 场景和舞台
        Scene scene = new Scene(borderPane, 800, 640);
        stage.setTitle("口算习题薄");
        stage.setScene(scene);
        stage.show();
    }

    // 初始化用户界面
    private void initializeUI() {
        // 清空现有题目VBox的内容
        questionVBox.getChildren().clear();

        // 生成并显示题目
        generateAndDisplayQuestions();

        // 创建检查按钮和结果标签
        Button checkButton = new Button("检查");
        Label resultLabel = new Label();

        // 检查按钮事件处理
        checkButton.setOnAction(event -> {
            int correctCount = checkAnswers(answerFields);
            resultLabel.setText("分数: " + correctCount + "/" + NUM_QUESTIONS);
            displayAccuracyChart(correctCount);
        });

        // 添加控件到题目VBox
        questionVBox.getChildren().addAll(answerFields);
        questionVBox.getChildren().add(checkButton);
        questionVBox.getChildren().add(resultLabel);
        questionVBox.getChildren().add(accuracyChart);
    }

    // 从数据库加载并显示题目
    private void loadAndDisplayDatabaseQuestions() {
        // 清空现有题目VBox的内容
        questionVBox.getChildren().clear();

        // 从数据库获取最新的题目
        List<IEquation> latestQuestions = getLatestQuestionsFromDatabase(NUM_QUESTIONS);
        equationCollection.clear(); // 清空现有的题目
        equationCollection.addAll(latestQuestions); // 添加最新的题目
        answerFields = new TextField[NUM_QUESTIONS];

        // 显示题目
        for (int i = 0; i < NUM_QUESTIONS; i++) {
            IEquation equation = equationCollection.getEquationsList().get(i);

            // 打印每个生成的习题到控制台
            System.out.println("问题读取 " + (i + 1) + ": " + equation.toString());

            HBox questionBox = createQuestionBox(i + 1, equation);
            questionVBox.getChildren().add(questionBox);
        }

        accuracyChart.getData().clear(); // 清空准确度图表

        // 清空答案输入框
        for (TextField answerField : answerFields) {
            answerField.clear();
        }

        // 创建检查按钮和结果标签
        Button checkButton = new Button("检查");
        Label resultLabel = new Label();

        // 检查按钮事件处理
        checkButton.setOnAction(event -> {
            int correctCount = checkAnswers(answerFields);
            resultLabel.setText("分数: " + correctCount + "/" + NUM_QUESTIONS);
            displayAccuracyChart(correctCount);
        });

        // 添加控件到题目VBox
        questionVBox.getChildren().addAll(answerFields);
        questionVBox.getChildren().add(checkButton);
        questionVBox.getChildren().add(resultLabel);
        questionVBox.getChildren().add(accuracyChart);
    }

    // 从数据库获取最新的题目
    private List<IEquation> getLatestQuestionsFromDatabase(int numQuestions) {
        try (Connection connection = MySQLUtil.getConnection()) {
            return MySQLUtil.getLatestEquations(connection, numQuestions);
        } catch (SQLException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return Collections.emptyList();
    }

    // 生成并显示题目
    private void generateAndDisplayQuestions() {
        equationCollection.generate(NUM_QUESTIONS, new EquationCheckerOfRange(0, 100));
        answerFields = new TextField[NUM_QUESTIONS];

        // 清空题目VBox
        questionVBox.getChildren().clear();

        // 显示题目
        for (int i = 0; i < NUM_QUESTIONS; i++) {
            IEquation equation = equationCollection.getEquationsList().get(i);

            // 打印每个生成的习题到控制台
            System.out.println("问题生成 " + (i + 1) + ": " + equation.toString());

            HBox questionBox = createQuestionBox(i + 1, equation);
            questionVBox.getChildren().add(questionBox);
        }

        accuracyChart.getData().clear(); // 清空准确度图表

        // 清空答案输入框
        for (TextField answerField : answerFields) {
            answerField.clear();
        }
    }

    // 将题目保存到数据库
    private void saveEquationsToDatabase() {
        try (Connection connection = MySQLUtil.getConnection()) {
            for (IEquation equation : equationCollection.getEquationsList()) {
                MySQLUtil.insertEquation(connection, equation.getOperand1(), String.valueOf(equation.getOperator()), equation.getOperand2());
            }
        } catch (SQLException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    // 检查答案并显示准确度图表
    private void checkAnswersAndDisplayChart() {
        int correctCount = checkAnswers(answerFields);
        displayAccuracyChart(correctCount);
    }

    // 显示准确度图表
    private void displayAccuracyChart(int correctCount) {
        accuracyChart.getData().clear();
        accuracyChart.getData().add(new PieChart.Data("正确", correctCount));
        accuracyChart.getData().add(new PieChart.Data("错误", NUM_QUESTIONS - correctCount));
    }

    // 创建题目的HBox
    private HBox createQuestionBox(int questionNumber, IEquation equation) {
        Label questionLabel = new Label("问题 " + questionNumber + ": ");
        Label equationLabel = new Label(equation.toString());

        HBox hbox = new HBox();
        hbox.getChildren().addAll(questionLabel, equationLabel);

        // 将答案输入框添加到数组以便以后检查
        answerFields[questionNumber - 1] = new TextField();

        hbox.getChildren().add(answerFields[questionNumber - 1]);
        return hbox;
    }

    // 检查答案
    private int checkAnswers(TextField[] answerFields) {
        int correctCount = 0;

        for (int i = 0; i < NUM_QUESTIONS; i++) {
            try {
                int userAnswer = Integer.parseInt(answerFields[i].getText());
                int actualAnswer = equationCollection.getEquationsList().get(i).calculate();

                if (userAnswer == actualAnswer) {
                    correctCount++;
                }
            } catch (NumberFormatException e) {
                // 忽略非整数输入
            }
        }

        return correctCount;
    }

    // 检查答案并显示准确度对话框
    private void showAccuracyDialog(int correctCount) {
        double accuracy = (double) correctCount / NUM_QUESTIONS * 100;

        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("准确度报告");
        alert.setHeaderText("准确度报告");
        alert.setContentText("你正确回答了 " + correctCount + " 题，准确度为 " + accuracy + "%");

        ButtonType okButton = new ButtonType("确定", ButtonBar.ButtonData.OK_DONE);
        alert.getButtonTypes().setAll(okButton);

        Optional<ButtonType> result = alert.showAndWait();
        if (result.isPresent() && result.get() == ButtonType.OK) {
            // 用户点击了确定按钮
            // 可以添加处理逻辑，如果需要的话
        }
    }

    public static void main(String[] args) {
        launch();
    }
}
package Mysql;

import ExerciseClass.AddEquation;
import ExerciseClass.IEquation;
import ExerciseClass.SubEquation;

import java.io.FileWriter;
import java.io.IOException;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * MySQL 数据库工具类。
 * 提供了连接数据库、执行 SQL 语句、插入和查询方程数据等功能。
 */
public class MySQLUtil {

	// JDBC 驱动和数据库连接参数
	private static final String JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";
	private static final String DB_URL = "jdbc:mysql://localhost:3306/app";
	private static final String URL_EXTRA_PARA = "?characterEncoding=utf8&serverTimezone=Asia/Shanghai&useSSL=false";
	private static final String USER = "root";
	private static final String PASS = "2003Kangwenqiao";

	// SQL 语句
	private static final String INSERT_SQL = "INSERT INTO eq (op_num1, operation, op_num2) VALUES (?, ?, ?)";
	private static final String SELECT_ALL_SQL = "SELECT * FROM eq";
	private static final String TRUNCATE_TABLE_SQL = "TRUNCATE TABLE eq";
	private static final String SELECT_LATEST_SQL = "SELECT * FROM eq ORDER BY id DESC LIMIT ?";

	/**
	 * 获取数据库连接。
	 *
	 * @return 数据库连接对象
	 * @throws SQLException            SQL 异常
	 * @throws ClassNotFoundException 类未找到异常
	 */
	public static Connection getConnection() throws SQLException, ClassNotFoundException {
		Class.forName(JDBC_DRIVER);
		return DriverManager.getConnection(DB_URL + URL_EXTRA_PARA, USER, PASS);
	}

	/**
	 * 查询并打印所有方程数据。
	 *
	 * @param connection 数据库连接对象
	 */
	public static void selectAllData(Connection connection) {
		try (PreparedStatement preparedStatement = connection.prepareStatement(SELECT_ALL_SQL);
			 ResultSet resultSet = preparedStatement.executeQuery()) {

			while (resultSet.next()) {
				// 打印每一行方程数据
				System.out.println("ID: " + resultSet.getInt("id") +
						", op_num1: " + resultSet.getInt("op_num1") +
						", operation: " + resultSet.getString("operation") +
						", op_num2: " + resultSet.getInt("op_num2"));
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	/**
	 * 清空整个表。
	 *
	 * @param connection 数据库连接对象
	 */
	public static void truncateTable(Connection connection) {
		try (Statement statement = connection.createStatement()) {
			// 执行清空表的 SQL 语句
			statement.executeUpdate(TRUNCATE_TABLE_SQL);
			System.out.println("表已被清空。");
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	/**
	 * 插入方程数据并获取自增主键。
	 *
	 * @param connection 数据库连接对象
	 * @param opNum1     操作数1
	 * @param operation  操作符
	 * @param opNum2     操作数2
	 */
	public static void insertEquation(Connection connection, int opNum1, String operation, int opNum2) {
		try (PreparedStatement preparedStatement = connection.prepareStatement(INSERT_SQL, Statement.RETURN_GENERATED_KEYS)) {
			preparedStatement.setInt(1, opNum1);
			preparedStatement.setString(2, operation);
			preparedStatement.setInt(3, opNum2);

			preparedStatement.executeUpdate();

			// 获取插入的题目的自增主键值
			ResultSet generatedKeys = preparedStatement.getGeneratedKeys();
			if (generatedKeys.next()) {
				int equationId = generatedKeys.getInt(1);
				System.out.println("题目已插入到数据库，ID: " + equationId);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	/**
	 * 获取最新的方程数据列表。
	 *
	 * @param connection    数据库连接对象
	 * @param numQuestions  获取的方程数量
	 * @return 最新的方程数据列表
	 * @throws SQLException SQL 异常
	 */
	public static List<IEquation> getLatestEquations(Connection connection, int numQuestions) throws SQLException {
		List<IEquation> equations = new ArrayList<>();

		// 查询最新的方程数据
		try (PreparedStatement preparedStatement = connection.prepareStatement(SELECT_LATEST_SQL)) {
			preparedStatement.setInt(1, numQuestions);

			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					short operand1 = resultSet.getShort("op_num1");
					char operator = resultSet.getString("operation").charAt(0);
					short operand2 = resultSet.getShort("op_num2");

					// 根据数据库中的数据创建 IEquation 对象
					IEquation equation = createEquation(operator, operand1, operand2);
					equations.add(equation);
				}
			}
		}

		return equations;
	}

	/**
	 * 根据操作符和操作数创建 IEquation 对象。
	 *
	 * @param operator 操作符
	 * @param operand1 操作数1
	 * @param operand2 操作数2
	 * @return IEquation 对象
	 */
	public static IEquation createEquation(char operator, short operand1, short operand2) {
		if (operator == '+') {
			return new AddEquation(operand1, operand2);
		} else if (operator == '-') {
			return new SubEquation(operand1, operand2);
		} else {
			throw new IllegalArgumentException("无效的操作符: " + operator);
		}
	}

}
package javafx;

import Mysql.MySQLUtil;

import java.sql.Connection;
import java.sql.SQLException;

public class MainNew {
    public static void main(String[] args) {
        try (Connection connection = MySQLUtil.getConnection()) {
            MySQLUtil.truncateTable(connection);
        } catch (SQLException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        EquationApplication.main(args);
    }
}
